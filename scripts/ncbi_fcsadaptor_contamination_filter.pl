#!/usr/bin/perl

my $version = "0.1";

use strict;
use warnings;

my $usage = "
ncbi_contamination_filter.pl

Filter sequence file based on fcs_adaptor_report.txt file generated by run_fcsadaptor.sh
(https://github.com/ncbi/fcs)

Required:
  -f    Original fasta file used as input 
  -c    fcs_adaptor_report.txt generated by run_fcsadaptor.sh
  
Optional:
  -l    Minimum sequence length to retain after trimming, in bp
        (default: 200)
  -s    Don't modify SPAdes contig IDs. If this option is selected, the IDs on
        trimmed sequences will be output unchanged with the exception of the
        addition of '.1' and '.2' to split contigs.
        Default will be to modify SPAdes format IDs, i.e.
        'NODE_xxx_length_yyy_cov_zzz'
        where xxx is the node number, yyy is the contig length, and zzz is the
        kmer coverage. IDs will be modified appropriately, i.e. lengths will be
        changed to reflect truncated contigs and split contigs will have '.1'
        and '.2' appended to the node numbers

";

use Getopt::Std;
our ($opt_f, $opt_c, $opt_l, $opt_s);
getopts('f:c:l:s');

die $usage unless ($opt_f and $opt_c);

my $minctg  = $opt_l ? $opt_l : 200;

open (my $cin, "<$opt_c") or die "ERROR: Can't open $opt_c: $!\n";
my %trims;
while (my $line = <$cin>){
    chomp $line;
    next if $line =~ m/^#/;
    my ($id, $leng, $type, $coords) = split("\t", $line);
    if ($type eq "ACTION_EXCLUDE"){
        print STDERR "Exclude $id\n";
        if ($trims{$id}){
            utime(time(), time(), "contamination_screen_failed");
            die "ERROR: $id already seen\n"; 
        }
        @{$trims{$id}} = (1, $leng);
    } elsif ($type eq "ACTION_TRIM"){
        $coords =~ m/(\d+)\.\.(\d+)/;
        my ($start, $stop) = ($1, $2);
        my $front_leng = $start - 1;
        my $back_leng = $leng - $stop;
        print STDERR "Trim $id, front:$front_leng, back:$back_leng\n";
        if ($trims{$id}){
            utime(time(), time(), "contamination_screen_failed");
            die "ERROR: $id already seen\n"; 
        }
        if ($front_leng < $minctg and $back_leng < $minctg){
            print STDERR "\texcluding\n";
            @{$trims{$id}} = (1, $leng);
        } elsif ($front_leng < $minctg){
            print STDERR "\ttrimming front\n";
            @{$trims{$id}} = (1, $stop);
        } elsif ($back_leng < $minctg){
            print STDERR "\ttrimming back\n";
            @{$trims{$id}} = ($start, $leng);
        } else {
            print STDERR "\tseparating\n";
            @{$trims{$id}} = ($start, $stop);
        }
    }
}
close ($cin);

open (my $fin, "<$opt_f") or die "ERROR: Can't open $opt_f: $!\n";
my $id;
my $sleng = 0;
my @seq;
while (my $line = <$fin>){
    chomp $line;
    next if $line =~ m/^\s*$/;
    if ($line =~ m/^>/){
        if ($id){
            if ($trims{$id}){
                my ($start, $stop) = @{$trims{$id}};
                my $fullseq = join("", @seq);
                trim($id, $fullseq, $start, $stop);
            } else {
                print ">$id\n", join("\n", @seq), "\n";
            }
        }
        @seq = ();
        $sleng = 0;
        $line =~ s/\s.*$//g;
        $id = substr($line, 1);
        next;
    }
    $line =~ s/\s//g;
    $sleng += length($line);
    push @seq, $line;
}
close ($fin);
if ($id){
    if ($trims{$id}){
        my ($start, $stop) = @{$trims{$id}};
        my $fullseq = join("", @seq);
        trim($id, $fullseq, $start, $stop);
    } else {
        print ">$id\n", join("\n", @seq), "\n";
    }
} else {
    die "ERROR: No sequences found in $opt_f\n";
}

sub trim {
    my $id = shift;
    my $fullseq = shift;
    my $start = shift;
    my $stop = shift;
    if ($start > 1 or $stop < $sleng){
        if ($start == 1){
            my $outseq = substr($fullseq, $stop);
            my $dist = length($fullseq) - $stop;
            $id = idmod($id, $dist) unless $opt_s;
            print ">$id\n$outseq\n";
        } elsif ($stop == $sleng){
            my $outseq = substr($fullseq, 0, $start - 1);
            my $dist = $start - 1;
            $id = idmod($id, $dist) unless $opt_s;
            print ">$id\n$outseq\n";
        } else {
            my $outseq1 = substr($fullseq, 0, $start - 1);
            my $dist = $start - 1;
            my $id1 = idmod($id, $dist, 1) unless $opt_s;
            print ">$id1\n$outseq1\n";
            my $outseq2 = substr($fullseq, $stop);
            $dist = length($fullseq) - $stop;
            my $id2 = idmod($id, $dist, 2) unless $opt_s;
            print ">$id2\n$outseq2\n";
        }
    } #else print nothing
    return(0);
}

sub idmod {
    my $fullid = shift;
    my $leng = shift;
    my $suffix = shift;
    unless ($fullid =~ m/^NODE_\d+_length_\d+_cov_\d+/){
        $fullid .= ".$suffix" if $suffix;
        return($fullid);
    }
    $fullid =~ s/_length_\d+/_length_$leng/;
    if ($suffix){
        $fullid =~ s/NODE_(\d+)/NODE_$1.$suffix/;
    }
    return $fullid;
}
